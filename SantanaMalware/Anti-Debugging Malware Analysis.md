# **Analysis of Santa**

## **Intro:**

When I first started looking into this sample, I didn't know that I would go down this rabbit hole. This article attempts to find and piece together the *anti-debugging* capabilities that reside within this malware sample that I have renamed to *Santa*(more on that below). We begin with some basic static analysis and slowly begin to put the puzzle pieces together using MalCat and Ghidra, then we end the process with testing our theories in the debugger. I hope you enjoy and learn something new!

## <ins>**Static Analysis**</ins>

### **SHA256**

- 683a09da219918258c58a7f61f7dc4161a3a7a377cf82a31b840baabfb9a4a96

### **MD5**

- 46bfd4f1d581d7c0121d2b19a005d3df

### **VirusTotal Output**

- I thought this said *Santa* on initial download, turns out its *Satana*, from the Satan family of malware, I will be referring to this as ***Santa*** or ***Santana*** from now on, shine some light on this dark world
- This output from VirusTotal is what initially sparked my interest to analyse the *anti-debugging* capabilities of this sample
![8e689a2ce07e823428111907f34e9762](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/574fe05d-e510-4721-a8f6-de9ffa3adbc4)

## <ins>**Initial MalCat Report**</ins>

- This appears to be a packed binary
- It is a 32bit executable
- The Compile Date is: 2009-11-10 10:17:40 ***Allegedly***  
![f50173c27e819df0c6d17816b9eea67f](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/f7dc5ac9-f95c-417e-93df-311f30b3bdb2)

### **Capa Output in MalCat**

We do have some things that are note worthy from this output

- Virtual Machine Detection
- Sandbox Evasion  
![7e367e51f999d515084b9de4c8702c7a](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/1039b5e9-2630-4dd4-95e4-14cb8348a5cd)   
- This capa output also lists where in the memory it has detected a potential malicious structure. For example, we detected anti-VM strings located at 4040f0; This wasnt the only output from this capa analysis, we also got hits on anti-debugging, inspection of user privileges, and several more. This will be fun to look into once we get into Ghidra!  
![421de5ae43c802321618659354744913](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/1d2c4700-e2e7-4b56-adf4-4b29d5a536cd)

## <ins>**Strings**</ins>

### **MyUnhandledExceptionFilter**

![6a449400cf565481cbedd7d5e051c23b-1](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/d8b084ea-cba6-417e-a936-1d4ce5f3b4bb)

- I found this to be interesting, as there is a windows API called "UnhandledExceptionFilter" -Â  https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-unhandledexceptionfilter
- Which lets you tell the debugger how to act at certain points in memory, so I am guessing the author of this has their own debugging rules, or possibly an API hook? We'll have to dig into this further

### **ClickOnce**

- Now I am rather new to reverse engineering and computers in general, so I have never seen this before and wanted to investigate further.  
![aa75a11aa515cde80efef6bbf6fdb018](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/db7d25d0-1f21-49c9-a4e0-f1384b731867)
   
- Through some research I eventually found my way here: https://learn.microsoft.com/en-us/visualstudio/deployment/clickonce-security-and-deployment?view=vs-2022
    
- This appears to be a way to create or *manifest* a "ClickOnce Application", which allows this malware to self-update, possibly could be how this sample executes a second stage? I have yet to find a URL, besides the ones listed above; I definitely need to work on my deobfuscation
    
- It installs, executes and updates a .NET application on a user endpoint with minimal to no user interaction
    
- Which to me.... Sounds a little ***sus***
    
- Through some more research I found this DEFCON talk, using this framework offensively: https://www.youtube.com/watch?v=cyHxoKvD8Ck
    
- This is an interesting protocol and it can be heavily leveraged for bad and good. It is currently out of scope for this analysis, but I wanted to take note of it for later testing
    

# <ins>**Ghidra Analysis**</ins>

## **Imports**

One of the first places I usually like to start with is the imports and where the references are located to those imports.
![a635cabb2e4b0719166799dda3138d97](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/30767245-6242-48f3-bfae-1d4f38c09e81)

Some notable imports such as GetLocalTime, OutputDebugStringA, NtYieldExecution, memset, memmove, and a whole lot of references to OpenGL. I am not to sure where OpenGL fits into the equation, maybe to control the window after the files have been encrypted, or possibly some sort of injection of persistence?

*OutputDebugStringA* was catching my attention. We know from earlier analysis that there was anti-debugging capabilities detected, and I want to know how that all works, so I will use this as my pivot point into the code base. The reference to this import was located in one function that I named GET_EXCEPTION.

![468367f16e14ff733972fc9ee0a81681](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/8afe9dbb-afbb-411c-af1c-3c887aa90d14)

This function was already readable being so small, but I changed some of the variables to try and derive more sense. The function parameter is the desired format you would like to print the result in, so calling this function later would look like `GET_EXCEPTION("%s")`. The buffer is just the location in memory this string is stored, and then we reference what I have determined to be the debug exception list at the stack address. OutputDebugStringA then prints the string located in the buffer to the debugger. It then returns that string for use in whatever function calls this.

Now that we have a basic idea of how a string is selected and printed to the debugger output, lets dig a a little deeper and see where this function is used in the program. This code is referenced in multiple areas throughout this program, and I decided to start at the entry point.

## **Avoid Debugging**

The start of the anti-debugging capabilities begin at the alleged entry point of this program. In the entry point, there is only one function called that after some time analysing, I feel comfortable to say that this is where these anti-debugging capabilities reside, I named the function AVOID_DEBUGGING.  
![entry_point_ghidra](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/e778026e-fd00-429a-8420-f9ec65344894)

I stepped through this function to the best of my abilities and I am sure I made some errors. Regardless, I am still pretty confident in the result, as it was the only function I could find that got the system time, called the GET_EXCEPTION function multiple times, performed bit-wise operations, and also yielded execution on specific threads. Let's take a deeper look.

First, we have our redefined variable names. I'll say this up-front, renaming variables and functions when reverse engineering is ***not easy***, there is a couple of names here that I am not 100% on, but I digress. First the function starts by throwing an exception from the function reviewed earlier, then it calculates the offset and sets the result to a variable. if it detects that there is an offset, we begin our debug timer. After the debug timer has been started, the function then prints the next exception statement and yields execution on that particular thread. I'll be totally honest, I am not sure how the call to OpenGl works, or why it is in the code to begin with, when I reviewed the function, it doesn't seem to be doing much, so we'll leave that for a later time.

![96c8f6081cd39636380b7e8876886787](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/0ef0c879-d8b7-4551-8f83-81b3ee8e7188)

After the program throws its first two exceptions, we enter a loop that continually yields execution of memory threads, throws more exceptions, and finally ends the process with a variable that I believe I named **incorrectly** as *address_out.* Regardless, to perform a *Software Interrupt -SWI function*, or `swi(3)` in the case of this code.  
![8a6210af245954e812db20bca73288c0](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/5618c910-5907-4fc7-b79f-54723693eb96)

We'll soon come to find how this anti-debugging loop works and eventually where the program crashes when we start debugging this process, but first, I wanted to bring an important piece to the anti-debugging puzzle I stumbled upon when first entering ghidra.

## **MOV EDI, EDI**

***This had me curious***, why does EDI get moved into EDI?  
![cc81d22d9d0d2b9610f5e190e419eb4d](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/21aee166-8001-4a5a-90c8-28ec277418b0) 
Well, it turns out that this is used in a windows .dll to perform something called *hot patching*. This *almost* acts just like a two-byte NOP that allows this section of the program to be used as a jump call, redirecting the flow of execution if certain criteria is met previously. More on hot patching here: https://devblogs.microsoft.com/oldnewthing/20110921-00/?p=9583

I'll be honest, I don't fully understand what this function is doing, it consists of several boolean operations, however, I found this part to be interesting; this function with the hot patch, is located just before the entry point of the program. Which, calls the AVOID_DEBUGGING function that begins the process of shutting down the debugging process as we will soon come to see. This process is referred to as an *inline hook*, you can find more on performing an inline hook on a function from this really great article here: https://blog.securehat.co.uk/process-injection/manually-implementing-inline-function-hooking#step-1-build-the-trampoline

## <ins>**Debugging**</ins>

- Finally I am ready to see this in action, we will first set our break point on the address we got from ghidra  
![d50e6f7b1b224a0014ff38518df5c2bc](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/8666ce6e-9d6b-49fc-ba46-8bd828e889aa)
- We have some interesting output from the debugging log, right before we get to our first break point we load in these modules:  
![786565c3137a172aa4cef03365b52bd0](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/ee844c77-67bb-4881-af6b-0c7597930ac7)
- Lots of nefarious calls in here, but I wanted to bring attention to NtUserBlockInput, the very first call. This is a boolean function that determines if the mouse and keyboard are working in your environment. Several times during my debugging process, my keyboard and my mouse would go out and I originally thought it was just some random error as I am running a windows virtual machine with many modifications for malware analysis. Now, I believe this call was the culprit.
- After we set our break point, x32debug shows us where the EIP is pointing to. In this case it points to 0040281A, which happens to be right towards the end of the AVOID_DEBUGGING function which has the Software Interrupt instruction.
![8582d1d4cfdfb2ef63ffd8b519aa1a3a](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/7d0208c9-a875-411f-81c3-a78b0caf68a8)

- Once this breakpoint is reached, a few more notable items appear in the log:  
![a31da9de12e25ab53cbbad52b9c90720](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/7c360c90-95fe-451f-9e54-d0d34485f943)
- We can see that by the time the program reaches the breakpoint at 0040281A, the debugger outputs an exception error, then begins the flow of execution at the end of our anti-sandbox function. What happens if we run it again? Well, I am going to have to get that on video, because all of the output from the debugger just disappears, however, we do have the logs to gain some insight:  
![fcad685361a54e49781ed577e75284e5](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/0d7165ce-8a96-438c-9fca-22f5dfe2c685)
- If I was debugging this normally without knowing what was going on, I would be pretty upset, but since that is not the case, I am thrilled to see it working as predicted earlier, really cool to see this in action! After many hours of going back and forth from MalCat to Ghidra to try and get some idea of what all these different variables/function calls are and more importantly, what they are doing; I am satisfied with the result of the analysis
- I wasnt able to touch on every function used for these anti-debugging capabilities, however, I do plan to do a part two to this analysis, so for now, here is a preview

## <ins>**Part Two: Preview**</ins>

- After coming to the end of the first part in this analysis, I was doing some post-game debugging to see if I can step around this function, I *kind of* did. The debug output still disappeared, however, we spawned a new process that I have yet to see.  
![c52b4559a64994107327ade212a0fc4c](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/592f6223-8e70-4c6d-b15e-daeb4fd82dac)
- This is interesting, at first I *half-thought* this could be a legitimate process, due to the debugger threads getting canceled, but I must know, so I immediately input this file to MalCat to get a quick initial look, and I found this:  
![b85621a1a244d39465a5b333b427d11c](https://github.com/ChrispySignal/Malware_Analysis/assets/155141952/c45739c3-cd90-42e3-85d6-471ce4e4e546)
- This wasn't the only interesting thing I found, there was stack string obfuscation, SHA256 hashes, anti-sandbox capabilities and more. However, its time to end this article here and work on some other projects for a little bit.

## <ins>**Conclusion**</ins>

If you're still here reading, cheers! I really appreciate it, many late nights were required to do this analysis. The next part to this series will come sometime within the next month or so as I have other projects to work on. If you have any questions or comments please reach out! I am rather new to this as well so if you have any pointers then please share those as well. This is meant as a project for me to grow from, become better at reverse engineering and hopefully meet some people in the community, Thanks!

## <ins>**Tools Used in Analysis**</ins>

### **Joplin:**

- I have recently come across Joplin while looking for a free, simple note taking software, and it is now an essential part of my workflow. You can type directly in .md format, or, write in a normal text editor with more features, you can also export in multiple formats. It is a great tool for research and documenting your findings.

### **MalCat:**

- Recently, I have picked up MalCat as a tool to explore malicious binaries. It is a *newish* hex editor with many capabilities and is modular with ***Python***, ***Capa***, and ***Yara***. This is a very powerful tool that I can't wait to learn more about. It gives you a great first look at a binary and has improved my workflow greatly, it is an awesome companion to whatever disassembler and debugger you are using. I stepped back and forth between this and ghidra often throughout this process

### **Ghidra:**

- Ghidra is a well known tool in the industry, comes in a full package with a good decompiler, decently organised, looks *ok* with dark mode enabled. It was designed by the NSA, so if that makes you upset you might want to look at other tools. I use it at the moment because it is completely free, all the features are yours to try out, even if some arent the greatest.

### **x32dbg**

- This was my first time using this debugger and I enjoyed the process a ton! The UI looks really good and has a whole lot of information to parse through, you can right click nearly everything and do something with whatever you clicked on. This sounds trivial, but when you think about it, this is an incredibly important thing to have in a piece of software like this. I can't wait to dive deeper.

### **Santana Sample**

- If you are interested in analyzing this sample yourself, I got this sample from this github repo: https://github.com/Haroun-Haeder/MalwareDatabase

* * *

* * *

* * *
